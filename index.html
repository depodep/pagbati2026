<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy New Year 2026!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            position: relative;
        }

        :root {
            --color-text: #f5ebe0;
            --color-accent: #ffd700;
        }

        html, body {
            height: 100%;
            background: #000;
        }

        body {
            font-family: 'Georgia', serif;
            color: var(--color-text);
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        #opening-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0f2e 100%);
            z-index: 10000;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #opening-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .countdown-time {
            font-size: clamp(3rem, 12vw, 6rem);
            font-weight: 300;
            letter-spacing: 0.1em;
            color: var(--color-accent);
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            font-family: 'Courier New', monospace;
            margin-bottom: 0.5rem;
        }

        .countdown-label {
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            color: rgba(245, 235, 224, 0.7);
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        .countdown-message {
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            color: var(--color-text);
            margin-top: 0.5rem;
            font-style: italic;
        }

        .start-btn {
            padding: 1rem 3rem;
            margin-top: 3rem;
            background: transparent;
            border: 2px solid var(--color-accent);
            color: var(--color-accent);
            font-size: 1.2rem;
            font-family: 'Georgia', serif;
            letter-spacing: 0.1em;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.4s ease;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .start-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.5);
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            position: absolute;
            mix-blend-mode: lighten;
            transform: translateZ(0);
        }

        #greeting-card {
            position: fixed;
            top: clamp(52%, calc(50% + 5vh), 55%);
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease 0.5s, visibility 1s ease 0.5s;
            max-width: min(90%, 420px);
            width: 88%;
            max-height: min(55vh, 500px);
            background: rgba(26, 15, 46, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 15px;
            padding: clamp(1rem, 3vw, 1.5rem) clamp(1rem, 3vw, 1.25rem);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.1);
            text-align: center;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #greeting-card::-webkit-scrollbar {
            width: 8px;
        }

        #greeting-card::-webkit-scrollbar-track {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
        }

        #greeting-card::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.4);
            border-radius: 10px;
        }

        #greeting-card::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.6);
        }

        #greeting-card.visible {
            opacity: 1;
            visibility: visible;
        }

        .greeting-header {
            position: fixed;
            top: clamp(3%, 5vh, 8%);
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            font-size: clamp(2rem, 7vw, 4.5rem);
            color: var(--color-accent);
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 80px rgba(255, 215, 0, 0.4);
            letter-spacing: 0.08em;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease 0.5s, visibility 1s ease 0.5s;
            text-align: center;
            width: 90%;
            margin: 0;
            padding: 0;
        }

        .greeting-header.visible {
            opacity: 1;
            visibility: visible;
        }

        .greeting-text {
            font-size: clamp(0.8rem, 2.5vw, 0.875rem);
            line-height: 1.6;
            color: rgba(245, 235, 224, 0.9);
            margin-bottom: clamp(0.75rem, 2vh, 1rem);
            text-align: left;
            white-space: pre-line;
        }

        .greeting-footer {
            margin-top: clamp(0.75rem, 2vh, 1rem);
            padding-top: clamp(0.75rem, 2vh, 1rem);
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            font-size: clamp(0.7rem, 2vw, 0.75rem);
            color: rgba(245, 235, 224, 0.6);
            font-style: italic;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 150;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="canvas-container">
        <canvas id="trails-canvas"></canvas>
        <canvas id="main-canvas"></canvas>
    </div>

    <canvas id="particle-canvas"></canvas>


    <h1 class="greeting-header">Happy New Year 2026</h1>

    <div id="greeting-card">
        <p class="greeting-text" id="greeting-text">To everyone I've crossed paths with—
thank you for being part of my journey, even in the simplest ways.

I may not always say much, and I don't always show things openly,
but I appreciate people deeply—those who stayed, those who taught me,
and even those who passed through and left a lesson behind.

This year reminded me that growth isn't always loud,
sometimes it's just choosing to keep going,
learning quietly, and becoming better than yesterday.

I wish you peace of mind, steady progress,
and moments that make life feel a little lighter.

Here's to moving forward—one step at a time,
with hope, patience, and purpose.</p>
            May 2026 bring you joy and growth ✨<br>
            -Peds
    </div>

    <script src="https://cdn.jsdelivr.net/npm/fscreen@1.2.0/dist/fscreen.min.js"></script>
    <script>
        'use strict';

        class ParticleSystem {
            constructor() {
                this.canvas = document.getElementById('particle-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            addParticles(x, y, count = 5) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x, y,
                        size: Math.random() * 8 + 3,
                        speedX: (Math.random() - 0.5) * 6,
                        speedY: (Math.random() - 0.5) * 6,
                        hue: Math.random() * 360,
                        life: 1
                    });
                }
            }

            update() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.life -= 0.015;
                    p.size *= 0.97;

                    if (p.life <= 0 || p.size < 0.5) {
                        this.particles.splice(i, 1);
                        continue;
                    }

                    this.ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life})`;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                requestAnimationFrame(() => this.update());
            }
        }

        let particleSystem;
        let greetingCard;

        // Auto-start on page load
        window.addEventListener('DOMContentLoaded', startFireworks);

        function startFireworks() {
            
            greetingCard = document.getElementById('greeting-card');
            
            particleSystem = new ParticleSystem();
            particleSystem.update();

            // Initialize fireworks first (this also initializes sound)
            initFireworks();
            
            // Play background music after audio context is ready
            const bgMusic = document.getElementById('bg-music');
            if (bgMusic) {
                bgMusic.volume = 0.3;
                bgMusic.play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Burst 1-3 random fireworks before showing card
            const burstCount = Math.floor(Math.random() * 3) + 1;
            let burstsCompleted = 0;
            
            const burstInterval = setInterval(() => {
                if (window.launchFireworkAt) {
                    const x = 0.2 + Math.random() * 0.6;
                    const height = 0.5 + Math.random() * 0.4;
                    window.launchFireworkAt(x, height);
                }
                
                burstsCompleted++;
                if (burstsCompleted >= burstCount) {
                    clearInterval(burstInterval);
                    // Show card and header after fireworks
                    setTimeout(() => {
                        greetingCard.classList.add('visible');
                        document.querySelector('.greeting-header').classList.add('visible');
                    }, 1500);
                }
            }, 400);

            // Card interactions
            let lastParticleTime = 0;
            document.addEventListener('mousemove', (e) => {
                const now = Date.now();
                if (now - lastParticleTime < 30) return;
                lastParticleTime = now;

                const rect = greetingCard.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right && 
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    particleSystem.addParticles(e.clientX, e.clientY, 3);
                }
            });

            // Click on card to launch fireworks
            greetingCard.addEventListener('click', (e) => {
                const rect = greetingCard.getBoundingClientRect();
                const relX = (e.clientX - rect.left) / rect.width;
                const relY = (e.clientY - rect.top) / rect.height;
                
                // Launch firework at card position
                if (window.launchFireworkAt) {
                    window.launchFireworkAt(e.clientX / window.innerWidth, 1 - e.clientY / window.innerHeight);
                }
            });
        }

        // Full fireworks implementation from CodePen
        function initFireworks() {
            const IS_MOBILE = window.innerWidth <= 640;
            const IS_DESKTOP = window.innerWidth > 800;
            const IS_HEADER = false;
            const IS_HIGH_END_DEVICE = navigator.hardwareConcurrency >= 4;
            const MAX_WIDTH = 7680;
            const MAX_HEIGHT = 4320;
            const GRAVITY = 0.9;
            let simSpeed = 1;

            let stageW, stageH;
            let quality = IS_HIGH_END_DEVICE ? 3 : 2;
            const isLowQuality = quality === 1;
            const isNormalQuality = quality === 2;
            const isHighQuality = quality === 3;

            const COLOR = {
                Red: '#ff0043',
                Green: '#14fc56',
                Blue: '#1e7fff',
                Purple: '#e60aff',
                Gold: '#ffbf36',
                White: '#ffffff'
            };

            const INVISIBLE = '_INVISIBLE_';
            const PI_2 = Math.PI * 2;
            const PI_HALF = Math.PI * 0.5;

            const COLOR_NAMES = Object.keys(COLOR);
            const COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]);
            const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];
            
            const COLOR_TUPLES = {};
            COLOR_CODES.forEach(hex => {
                COLOR_TUPLES[hex] = {
                    r: parseInt(hex.substr(1, 2), 16),
                    g: parseInt(hex.substr(3, 2), 16),
                    b: parseInt(hex.substr(5, 2), 16),
                };
            });

            // Stage class
            class Stage {
                constructor(id) {
                    this.canvas = document.getElementById(id);
                    this.ctx = this.canvas.getContext('2d');
                    this.width = 0;
                    this.height = 0;
                    this.dpr = window.devicePixelRatio || 1;
                }

                resize(w, h) {
                    this.width = w;
                    this.height = h;
                    this.canvas.width = w * this.dpr;
                    this.canvas.height = h * this.dpr;
                    this.canvas.style.width = w + 'px';
                    this.canvas.style.height = h + 'px';
                }
            }

            const trailsStage = new Stage('trails-canvas');
            const mainStage = new Stage('main-canvas');

            function createParticleCollection() {
                const collection = {};
                COLOR_CODES_W_INVIS.forEach(color => {
                    collection[color] = [];
                });
                return collection;
            }

            const Star = {
                drawWidth: 3,
                airDrag: 0.98,
                airDragHeavy: 0.992,
                active: createParticleCollection(),
                _pool: [],

                _new() { return {}; },

                add(x, y, color, angle, speed, life, speedOffX, speedOffY) {
                    const instance = this._pool.pop() || this._new();
                    instance.visible = true;
                    instance.heavy = false;
                    instance.x = x;
                    instance.y = y;
                    instance.prevX = x;
                    instance.prevY = y;
                    instance.color = color;
                    instance.speedX = Math.sin(angle) * speed + (speedOffX || 0);
                    instance.speedY = Math.cos(angle) * speed + (speedOffY || 0);
                    instance.life = life;
                    instance.fullLife = life;
                    instance.spinAngle = Math.random() * PI_2;
                    instance.spinSpeed = 0.8;
                    instance.spinRadius = 0;
                    instance.sparkFreq = 0;
                    instance.sparkSpeed = 1;
                    instance.sparkTimer = 0;
                    instance.sparkColor = color;
                    instance.sparkLife = 750;
                    instance.sparkLifeVariation = 0.25;
                    instance.strobe = false;
                    this.active[color].push(instance);
                    return instance;
                },

                returnInstance(instance) {
                    instance.onDeath && instance.onDeath(instance);
                    instance.onDeath = null;
                    instance.secondColor = null;
                    instance.transitionTime = 0;
                    instance.colorChanged = false;
                    this._pool.push(instance);
                }
            };

            const Spark = {
                drawWidth: quality === 3 ? 0.75 : 1,
                airDrag: 0.9,
                active: createParticleCollection(),
                _pool: [],

                _new() { return {}; },

                add(x, y, color, angle, speed, life) {
                    const instance = this._pool.pop() || this._new();
                    instance.x = x;
                    instance.y = y;
                    instance.prevX = x;
                    instance.prevY = y;
                    instance.color = color;
                    instance.speedX = Math.sin(angle) * speed;
                    instance.speedY = Math.cos(angle) * speed;
                    instance.life = life;
                    this.active[color].push(instance);
                    return instance;
                },

                returnInstance(instance) {
                    this._pool.push(instance);
                }
            };

            const BurstFlash = {
                active: [],
                _pool: [],
                _new() { return {}; },
                add(x, y, radius) {
                    const instance = this._pool.pop() || this._new();
                    instance.x = x;
                    instance.y = y;
                    instance.radius = radius;
                    this.active.push(instance);
                    return instance;
                },
                returnInstance(instance) {
                    this._pool.push(instance);
                }
            };

            const MyMath = {
                random(min, max) {
                    return Math.random() * (max - min) + min;
                },
                randomChoice(arr) {
                    return arr[Math.random() * arr.length | 0];
                },
                pointDist(x1, y1, x2, y2) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    return Math.sqrt(dx * dx + dy * dy);
                },
                pointAngle(x1, y1, x2, y2) {
                    return Math.atan2(y2 - y1, x2 - x1);
                },
                clamp(num, min, max) {
                    return Math.min(Math.max(num, min), max);
                }
            };

            function randomColorSimple() {
                return COLOR_CODES[Math.random() * COLOR_CODES.length | 0];
            }

            let lastColor;
            function randomColor(options) {
                const notSame = options && options.notSame;
                const notColor = options && options.notColor;
                const limitWhite = options && options.limitWhite;
                let color = randomColorSimple();
                
                if (limitWhite && color === COLOR.White && Math.random() < 0.6) {
                    color = randomColorSimple();
                }
                
                if (notSame) {
                    while (color === lastColor) color = randomColorSimple();
                } else if (notColor) {
                    while (color === notColor) color = randomColorSimple();
                }
                
                lastColor = color;
                return color;
            }

            function whiteOrGold() {
                return Math.random() < 0.5 ? COLOR.Gold : COLOR.White;
            }

            function makePistilColor(shellColor) {
                return (shellColor === COLOR.White || shellColor === COLOR.Gold) ? 
                    randomColor({ notColor: shellColor }) : whiteOrGold();
            }

            function createParticleArc(start, arcLength, count, randomness, particleFactory) {
                const angleDelta = arcLength / count;
                const end = start + arcLength - (angleDelta * 0.5);
                
                if (end > start) {
                    for (let angle = start; angle < end; angle = angle + angleDelta) {
                        particleFactory(angle + Math.random() * angleDelta * randomness);
                    }
                } else {
                    for (let angle = start; angle > end; angle = angle + angleDelta) {
                        particleFactory(angle + Math.random() * angleDelta * randomness);
                    }
                }
            }

            function createBurst(count, particleFactory, startAngle = 0, arcLength = PI_2) {
                const R = 0.5 * Math.sqrt(count / Math.PI);
                const C = 2 * R * Math.PI;
                const C_HALF = C / 2;
                
                for (let i = 0; i <= C_HALF; i++) {
                    const ringAngle = i / C_HALF * PI_HALF;
                    const ringSize = Math.cos(ringAngle);
                    const partsPerFullRing = C * ringSize;
                    const partsPerArc = partsPerFullRing * (arcLength / PI_2);
                    
                    const angleInc = PI_2 / partsPerFullRing;
                    const angleOffset = Math.random() * angleInc + startAngle;
                    const maxRandomAngleOffset = angleInc * 0.33;
                    
                    for (let j = 0; j < partsPerArc; j++) {
                        const randomAngleOffset = Math.random() * maxRandomAngleOffset;
                        let angle = angleInc * j + angleOffset + randomAngleOffset;
                        particleFactory(angle, ringSize);
                    }
                }
            }

            function crossetteEffect(star) {
                const startAngle = Math.random() * PI_HALF;
                createParticleArc(startAngle, PI_2, 4, 0.5, (angle) => {
                    Star.add(star.x, star.y, star.color, angle, Math.random() * 0.6 + 0.75, 600);
                });
            }

            function floralEffect(star) {
                const count = 12 + 6 * quality;
                createBurst(count, (angle, speedMult) => {
                    Star.add(star.x, star.y, star.color, angle, speedMult * 2.4, 
                        1000 + Math.random() * 300, star.speedX, star.speedY);
                });
                BurstFlash.add(star.x, star.y, 46);
            }

            function crackleEffect(star) {
                const count = isHighQuality ? 32 : 16;
                createParticleArc(0, PI_2, count, 1.8, (angle) => {
                    Spark.add(star.x, star.y, COLOR.Gold, angle, 
                        Math.pow(Math.random(), 0.45) * 2.4, 300 + Math.random() * 200);
                });
            }

            // Sound Manager
            const soundManager = {
                ctx: null,
                enabled: true,

                init() {
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                        // Resume audio context immediately to ensure sounds play
                        if (this.ctx.state === 'suspended') {
                            this.ctx.resume();
                        }
                    } catch (e) {
                        console.warn('Web Audio API not supported');
                        this.enabled = false;
                    }
                },

                createBurstSound(size = 1) {
                    if (!this.enabled || !this.ctx) return null;

                    const duration = 0.2 + size * 0.1 + Math.random() * 0.15;
                    const sampleRate = this.ctx.sampleRate;
                    const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                    const data = buffer.getChannelData(0);

                    const baseFreq = 80 + Math.random() * 80;
                    const noiseIntensity = 0.2 + Math.random() * 0.3;

                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / sampleRate;
                        const envelope = Math.exp(-t * (6 + Math.random() * 4));
                        const noise = (Math.random() * 2 - 1) * noiseIntensity;
                        const tone = Math.sin(2 * Math.PI * (baseFreq + size * 50) * t * Math.exp(-t * 2)) * 0.3;
                        data[i] = (noise + tone) * envelope;
                    }

                    return buffer;
                },

                createLaunchSound() {
                    if (!this.enabled || !this.ctx) return null;

                    const duration = 0.3 + Math.random() * 0.2;
                    const sampleRate = this.ctx.sampleRate;
                    const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                    const data = buffer.getChannelData(0);

                    const startFreq = 60 + Math.random() * 40;
                    const freqRange = 150 + Math.random() * 100;

                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / sampleRate;
                        const envelope = Math.exp(-t * (2.5 + Math.random() * 1));
                        const freq = startFreq + t * freqRange;
                        const noise = (Math.random() * 2 - 1) * (0.1 + Math.random() * 0.1);
                        const tone = Math.sin(2 * Math.PI * freq * t) * 0.2;
                        data[i] = (noise + tone) * envelope;
                    }

                    return buffer;
                },

                createPopperSound() {
                    if (!this.enabled || !this.ctx) return null;

                    const duration = 0.08 + Math.random() * 0.05;
                    const sampleRate = this.ctx.sampleRate;
                    const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < buffer.length; i++) {
                        const t = i / sampleRate;
                        const envelope = Math.exp(-t * 80);
                        const noise = (Math.random() * 2 - 1);
                        const click = Math.sin(2 * Math.PI * (2000 + Math.random() * 1000) * t);
                        data[i] = (noise * 0.7 + click * 0.3) * envelope;
                    }

                    return buffer;
                },

                play(buffer, volume = 1) {
                    if (!this.enabled || !this.ctx || !buffer) return;

                    try {
                        const source = this.ctx.createBufferSource();
                        const gainNode = this.ctx.createGain();
                        
                        source.buffer = buffer;
                        gainNode.gain.value = Math.min(volume * 0.5, 1);
                        
                        source.connect(gainNode);
                        gainNode.connect(this.ctx.destination);
                        source.start(0);
                    } catch (e) {
                        console.warn('Error playing sound:', e);
                    }
                }
            };

            class Shell {
                constructor(options) {
                    Object.assign(this, options);
                    this.starLifeVariation = options.starLifeVariation || 0.125;
                    this.color = options.color || randomColor();
                    this.glitterColor = options.glitterColor || this.color;
                    
                    if (!this.starCount) {
                        const density = options.starDensity || 1;
                        const scaledSize = this.spreadSize / 54;
                        this.starCount = Math.max(6, scaledSize * scaledSize * density);
                    }
                }

                launch(position, launchHeight) {
                    const width = stageW;
                    const height = stageH;
                    const hpad = 60;
                    const vpad = 50;
                    const minHeightPercent = 0.45;
                    const minHeight = height - height * minHeightPercent;
                    
                    const launchX = position * (width - hpad * 2) + hpad;
                    const launchY = height;
                    const burstY = minHeight - (launchHeight * (minHeight - vpad));
                    const launchDistance = launchY - burstY;
                    const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);
                    
                    const comet = this.comet = Star.add(
                        launchX, launchY,
                        typeof this.color === 'string' && this.color !== 'random' ? this.color : COLOR.White,
                        Math.PI,
                        launchVelocity * (this.horsetail ? 1.2 : 1),
                        launchVelocity * (this.horsetail ? 100 : 400)
                    );
                    
                    comet.heavy = true;
                    comet.spinRadius = MyMath.random(0.32, 0.85);
                    comet.sparkFreq = 32 / quality;
                    if (isHighQuality) comet.sparkFreq = 8;
                    comet.sparkLife = 320;
                    comet.sparkLifeVariation = 3;
                    
                    if (this.glitter === 'willow' || this.fallingLeaves) {
                        comet.sparkFreq = 20 / quality;
                        comet.sparkSpeed = 0.5;
                        comet.sparkLife = 500;
                    }
                    if (this.color === INVISIBLE) {
                        comet.sparkColor = COLOR.Gold;
                    }
                    
                    if (Math.random() > 0.4 && !this.horsetail) {
                        comet.secondColor = INVISIBLE;
                        comet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500;
                    }
                    
                    comet.onDeath = () => this.burst(comet.x, comet.y);
                    
                    // Play launch sound
                    const launchSound = soundManager.createLaunchSound();
                    soundManager.play(launchSound, 0.4);
                }

                burst(x, y) {
                    const speed = this.spreadSize / 96;
                    let color, onDeath, sparkFreq, sparkSpeed, sparkLife;
                    let sparkLifeVariation = 0.25;
                    let playedDeathSound = false;
                    
                    // Play burst sound
                    const burstSound = soundManager.createBurstSound(this.shellSize || 1);
                    soundManager.play(burstSound, 0.8);
                    
                    // Add random popper sounds after burst with random delays
                    const popperCount = Math.floor(Math.random() * 3) + 2; // 2-4 poppers
                    for (let i = 0; i < popperCount; i++) {
                        setTimeout(() => {
                            const popperSound = soundManager.createPopperSound();
                            soundManager.play(popperSound, 0.5 + Math.random() * 0.3);
                        }, 50 + Math.random() * 200); // Random delay between 50-250ms
                    }
                    
                    if (this.crossette) onDeath = crossetteEffect;
                    if (this.crackle) onDeath = crackleEffect;
                    if (this.floral) onDeath = floralEffect;
                    
                    if (this.glitter === 'light') {
                        sparkFreq = 400; sparkSpeed = 0.3; sparkLife = 300; sparkLifeVariation = 2;
                    } else if (this.glitter === 'medium') {
                        sparkFreq = 200; sparkSpeed = 0.44; sparkLife = 700; sparkLifeVariation = 2;
                    } else if (this.glitter === 'heavy') {
                        sparkFreq = 80; sparkSpeed = 0.8; sparkLife = 1400; sparkLifeVariation = 2;
                    } else if (this.glitter === 'thick') {
                        sparkFreq = 16; sparkSpeed = isHighQuality ? 1.65 : 1.5; 
                        sparkLife = 1400; sparkLifeVariation = 3;
                    } else if (this.glitter === 'willow') {
                        sparkFreq = 120; sparkSpeed = 0.34; sparkLife = 1400; sparkLifeVariation = 3.8;
                    }
                    
                    sparkFreq = sparkFreq / quality;
                    
                    const standardInitialSpeed = this.spreadSize / 1800;
                    const starFactory = (angle, speedMult) => {
                        const star = Star.add(
                            x, y, color || randomColor(), angle, speedMult * speed,
                            this.starLife + Math.random() * this.starLife * this.starLifeVariation,
                            this.horsetail ? this.comet && this.comet.speedX : 0,
                            this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed
                        );

                        if (this.secondColor) {
                            star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32);
                            star.secondColor = this.secondColor;
                        }

                        if (this.strobe) {
                            star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46);
                            star.strobe = true;
                            star.strobeFreq = Math.random() * 20 + 40;
                            if (this.strobeColor) star.secondColor = this.strobeColor;
                        }
                        
                        star.onDeath = onDeath;

                        if (this.glitter) {
                            star.sparkFreq = sparkFreq;
                            star.sparkSpeed = sparkSpeed;
                            star.sparkLife = sparkLife;
                            star.sparkLifeVariation = sparkLifeVariation;
                            star.sparkColor = this.glitterColor;
                            star.sparkTimer = Math.random() * star.sparkFreq;
                        }
                    };
                    
                    if (typeof this.color === 'string') {
                        if (this.color === 'random') {
                            color = null;
                        } else {
                            color = this.color;
                        }
                        
                        if (this.ring) {
                            const ringStartAngle = Math.random() * Math.PI;
                            const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;
                            
                            createParticleArc(0, PI_2, this.starCount, 0, angle => {
                                const initSpeedX = Math.sin(angle) * speed * ringSquash;
                                const initSpeedY = Math.cos(angle) * speed;
                                const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY);
                                const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle;
                                const star = Star.add(x, y, color, newAngle, newSpeed,
                                    this.starLife + Math.random() * this.starLife * this.starLifeVariation);
                                
                                if (this.glitter) {
                                    star.sparkFreq = sparkFreq;
                                    star.sparkSpeed = sparkSpeed;
                                    star.sparkLife = sparkLife;
                                    star.sparkLifeVariation = sparkLifeVariation;
                                    star.sparkColor = this.glitterColor;
                                    star.sparkTimer = Math.random() * star.sparkFreq;
                                }
                            });
                        } else {
                            createBurst(this.starCount, starFactory);
                        }
                    } else if (Array.isArray(this.color)) {
                        if (Math.random() < 0.5) {
                            const start = Math.random() * Math.PI;
                            const start2 = start + Math.PI;
                            const arc = Math.PI;
                            color = this.color[0];
                            createBurst(this.starCount, starFactory, start, arc);
                            color = this.color[1];
                            createBurst(this.starCount, starFactory, start2, arc);
                        } else {
                            color = this.color[0];
                            createBurst(this.starCount / 2, starFactory);
                            color = this.color[1];
                            createBurst(this.starCount / 2, starFactory);
                        }
                    }
                    
                    if (this.pistil) {
                        const innerShell = new Shell({
                            spreadSize: this.spreadSize * 0.5,
                            starLife: this.starLife * 0.6,
                            starLifeVariation: this.starLifeVariation,
                            starDensity: 1.4,
                            color: this.pistilColor,
                            glitter: 'light',
                            glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White
                        });
                        innerShell.burst(x, y);
                    }
                    
                    if (this.streamers) {
                        const innerShell = new Shell({
                            spreadSize: this.spreadSize * 0.9,
                            starLife: this.starLife * 0.8,
                            starLifeVariation: this.starLifeVariation,
                            starCount: Math.floor(Math.max(6, this.spreadSize / 45)),
                            color: COLOR.White,
                            glitter: 'streamer'
                        });
                        innerShell.burst(x, y);
                    }
                    
                    BurstFlash.add(x, y, this.spreadSize / 4);
                }
            }

            const crysanthemumShell = (size = 1) => {
                const glitter = Math.random() < 0.25;
                const singleColor = Math.random() < 0.72;
                const color = singleColor ? randomColor({ limitWhite: true }) : 
                    [randomColor(), randomColor({ notSame: true })];
                const pistil = singleColor && Math.random() < 0.42;
                const pistilColor = pistil && makePistilColor(color);
                const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? 
                    pistilColor || randomColor({ notColor: color, limitWhite: true }) : null;
                const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;
                let starDensity = glitter ? 1.1 : 1.25;
                if (isLowQuality) starDensity *= 0.8;
                if (isHighQuality) starDensity = 1.2;
                return {
                    shellSize: size,
                    spreadSize: 300 + size * 100,
                    starLife: 900 + size * 200,
                    starDensity,
                    color,
                    secondColor,
                    glitter: glitter ? 'light' : '',
                    glitterColor: whiteOrGold(),
                    pistil,
                    pistilColor,
                    streamers
                };
            };

            const palmShell = (size = 1) => {
                const color = randomColor();
                const thick = Math.random() < 0.5;
                return {
                    shellSize: size,
                    color,
                    spreadSize: 250 + size * 75,
                    starDensity: thick ? 0.15 : 0.4,
                    starLife: 1800 + size * 200,
                    glitter: thick ? 'thick' : 'heavy'
                };
            };

            const ringShell = (size = 1) => {
                const color = randomColor();
                const pistil = Math.random() < 0.75;
                return {
                    shellSize: size,
                    ring: true,
                    color,
                    spreadSize: 300 + size * 100,
                    starLife: 900 + size * 200,
                    starCount: 2.2 * PI_2 * (size + 1),
                    pistil,
                    pistilColor: makePistilColor(color),
                    glitter: !pistil ? 'light' : '',
                    glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White,
                    streamers: Math.random() < 0.3
                };
            };

            const crossetteShell = (size = 1) => {
                const color = randomColor({ limitWhite: true });
                return {
                    shellSize: size,
                    spreadSize: 300 + size * 100,
                    starLife: 750 + size * 160,
                    starLifeVariation: 0.4,
                    starDensity: 0.85,
                    color,
                    crossette: true,
                    pistil: Math.random() < 0.5,
                    pistilColor: makePistilColor(color)
                };
            };

            const floralShell = (size = 1) => ({
                shellSize: size,
                spreadSize: 300 + size * 120,
                starDensity: 0.12,
                starLife: 500 + size * 50,
                starLifeVariation: 0.5,
                color: Math.random() < 0.65 ? 'random' : 
                    (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]),
                floral: true
            });

            const willowShell = (size = 1) => ({
                shellSize: size,
                spreadSize: 300 + size * 100,
                starDensity: 0.6,
                starLife: 3000 + size * 300,
                glitter: 'willow',
                glitterColor: COLOR.Gold,
                color: INVISIBLE
            });

            const crackleShell = (size = 1) => {
                const color = Math.random() < 0.75 ? COLOR.Gold : randomColor();
                return {
                    shellSize: size,
                    spreadSize: 380 + size * 75,
                    starDensity: isLowQuality ? 0.65 : 1,
                    starLife: 600 + size * 100,
                    starLifeVariation: 0.32,
                    glitter: 'light',
                    glitterColor: COLOR.Gold,
                    color,
                    crackle: true,
                    pistil: Math.random() < 0.65,
                    pistilColor: makePistilColor(color)
                };
            };

            function randomShellName() {
                return Math.random() < 0.5 ? 'Crysanthemum' : 
                    shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0];
            }

            function randomShell(size) {
                return shellTypes[randomShellName()](size);
            }

            const shellTypes = {
                'Random': randomShell,
                'Crackle': crackleShell,
                'Crossette': crossetteShell,
                'Crysanthemum': crysanthemumShell,
                'Floral': floralShell,
                'Palm': palmShell,
                'Ring': ringShell,
                'Willow': willowShell
            };

            const shellNames = Object.keys(shellTypes);

            function getRandomShellSize() {
                const baseSize = IS_DESKTOP ? 3 : 2;
                const maxVariance = Math.min(2.5, baseSize);
                const variance = Math.random() * maxVariance;
                const size = baseSize - variance;
                const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance);
                const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;
                const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;
                return { size, x, height };
            }

            function seqRandomShell() {
                const size = getRandomShellSize();
                const shell = new Shell(randomShell(size.size));
                shell.launch(size.x, size.height);
                return 500; // 0.5 seconds between fireworks
            }

            // Export function to launch fireworks at specific position
            window.launchFireworkAt = function(x, height) {
                const size = Math.random() * 2 + 1;
                const shell = new Shell(randomShell(size));
                shell.launch(x, height);
            };

            let currentFrame = 0;
            let autoLaunchTime = 0;

            function handleResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const containerW = Math.min(w, MAX_WIDTH);
                const containerH = Math.min(h, MAX_HEIGHT);
                trailsStage.resize(containerW, containerH);
                mainStage.resize(containerW, containerH);
                stageW = containerW;
                stageH = containerH;
            }

            handleResize();
            window.addEventListener('resize', handleResize);
            
            // Initialize sound manager
            soundManager.init();

            const currentSkyColor = { r: 0, g: 0, b: 0 };
            const targetSkyColor = { r: 0, g: 0, b: 0 };

            function colorSky(speed) {
                const maxSkySaturation = 15;
                const maxStarCount = 500;
                let totalStarCount = 0;
                targetSkyColor.r = 0;
                targetSkyColor.g = 0;
                targetSkyColor.b = 0;
                
                COLOR_CODES.forEach(color => {
                    const tuple = COLOR_TUPLES[color];
                    const count = Star.active[color].length;
                    totalStarCount += count;
                    targetSkyColor.r += tuple.r * count;
                    targetSkyColor.g += tuple.g * count;
                    targetSkyColor.b += tuple.b * count;
                });
                
                const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3);
                const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);
                targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity;
                targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity;
                targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity;
                
                const colorChange = 10;
                currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed;
                currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed;
                currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed;
                
                document.body.style.backgroundColor = 
                    `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;
            }

            function update(frameTime, lag) {
                const width = stageW;
                const height = stageH;
                const timeStep = frameTime * simSpeed;
                const speed = simSpeed * lag;
                
                currentFrame++;
                autoLaunchTime -= timeStep;
                if (autoLaunchTime <= 0) {
                    autoLaunchTime = seqRandomShell() * 1.25;
                }
                
                const starDrag = 1 - (1 - Star.airDrag) * speed;
                const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;
                const sparkDrag = 1 - (1 - Spark.airDrag) * speed;
                const gAcc = timeStep / 1000 * GRAVITY;
                
                COLOR_CODES_W_INVIS.forEach(color => {
                    const stars = Star.active[color];
                    for (let i = stars.length - 1; i >= 0; i--) {
                        const star = stars[i];
                        if (star.updateFrame === currentFrame) continue;
                        star.updateFrame = currentFrame;
                        
                        star.life -= timeStep;
                        if (star.life <= 0) {
                            stars.splice(i, 1);
                            Star.returnInstance(star);
                        } else {
                            const burnRate = Math.pow(star.life / star.fullLife, 0.5);
                            const burnRateInverse = 1 - burnRate;

                            star.prevX = star.x;
                            star.prevY = star.y;
                            star.x += star.speedX * speed;
                            star.y += star.speedY * speed;
                            
                            if (!star.heavy) {
                                star.speedX *= starDrag;
                                star.speedY *= starDrag;
                            } else {
                                star.speedX *= starDragHeavy;
                                star.speedY *= starDragHeavy;
                            }
                            star.speedY += gAcc;
                            
                            if (star.spinRadius) {
                                star.spinAngle += star.spinSpeed * speed;
                                star.x += Math.sin(star.spinAngle) * star.spinRadius * speed;
                                star.y += Math.cos(star.spinAngle) * star.spinRadius * speed;
                            }
                            
                            if (star.sparkFreq) {
                                star.sparkTimer -= timeStep;
                                while (star.sparkTimer < 0) {
                                    star.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;
                                    Spark.add(star.x, star.y, star.sparkColor, Math.random() * PI_2,
                                        Math.random() * star.sparkSpeed * burnRate,
                                        star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife);
                                }
                            }
                            
                            if (star.life < star.transitionTime) {
                                if (star.secondColor && !star.colorChanged) {
                                    star.colorChanged = true;
                                    star.color = star.secondColor;
                                    stars.splice(i, 1);
                                    Star.active[star.secondColor].push(star);
                                    if (star.secondColor === INVISIBLE) {
                                        star.sparkFreq = 0;
                                    }
                                }
                                
                                if (star.strobe) {
                                    star.visible = Math.floor(star.life / star.strobeFreq) % 3 === 0;
                                }
                            }
                        }
                    }
                    
                    const sparks = Spark.active[color];
                    for (let i = sparks.length - 1; i >= 0; i--) {
                        const spark = sparks[i];
                        spark.life -= timeStep;
                        if (spark.life <= 0) {
                            sparks.splice(i, 1);
                            Spark.returnInstance(spark);
                        } else {
                            spark.prevX = spark.x;
                            spark.prevY = spark.y;
                            spark.x += spark.speedX * speed;
                            spark.y += spark.speedY * speed;
                            spark.speedX *= sparkDrag;
                            spark.speedY *= sparkDrag;
                            spark.speedY += gAcc;
                        }
                    }
                });
                
                render(speed);
            }

            function render(speed) {
                const { dpr } = mainStage;
                const width = stageW;
                const height = stageH;
                const trailsCtx = trailsStage.ctx;
                const mainCtx = mainStage.ctx;
                
                colorSky(speed);
                
                trailsCtx.scale(dpr, dpr);
                mainCtx.scale(dpr, dpr);
                
                trailsCtx.globalCompositeOperation = 'source-over';
                trailsCtx.fillStyle = `rgba(0, 0, 0, ${0.175 * speed})`;
                trailsCtx.fillRect(0, 0, width, height);
                
                mainCtx.clearRect(0, 0, width, height);
                
                while (BurstFlash.active.length) {
                    const bf = BurstFlash.active.pop();
                    const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);
                    burstGradient.addColorStop(0.024, 'rgba(255, 255, 255, 1)');
                    burstGradient.addColorStop(0.125, 'rgba(255, 160, 20, 0.2)');
                    burstGradient.addColorStop(0.32, 'rgba(255, 140, 20, 0.11)');
                    burstGradient.addColorStop(1, 'rgba(255, 120, 20, 0)');
                    trailsCtx.fillStyle = burstGradient;
                    trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);
                    BurstFlash.returnInstance(bf);
                }
                
                trailsCtx.globalCompositeOperation = 'lighten';
                trailsCtx.lineWidth = Star.drawWidth;
                trailsCtx.lineCap = isLowQuality ? 'square' : 'round';
                mainCtx.strokeStyle = '#fff';
                mainCtx.lineWidth = 1;
                mainCtx.beginPath();
                
                COLOR_CODES.forEach(color => {
                    const stars = Star.active[color];
                    trailsCtx.strokeStyle = color;
                    trailsCtx.beginPath();
                    stars.forEach(star => {
                        if (star.visible) {
                            trailsCtx.moveTo(star.x, star.y);
                            trailsCtx.lineTo(star.prevX, star.prevY);
                            mainCtx.moveTo(star.x, star.y);
                            mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);
                        }
                    });
                    trailsCtx.stroke();
                });
                mainCtx.stroke();

                trailsCtx.lineWidth = Spark.drawWidth;
                trailsCtx.lineCap = 'butt';
                COLOR_CODES.forEach(color => {
                    const sparks = Spark.active[color];
                    trailsCtx.strokeStyle = color;
                    trailsCtx.beginPath();
                    sparks.forEach(spark => {
                        trailsCtx.moveTo(spark.x, spark.y);
                        trailsCtx.lineTo(spark.prevX, spark.prevY);
                    });
                    trailsCtx.stroke();
                });
                
                trailsCtx.setTransform(1, 0, 0, 1, 0, 0);
                mainCtx.setTransform(1, 0, 0, 1, 0, 0);
            }

            let lastFrameTime = 0;
            function tick(currentTime) {
                if (!lastFrameTime) lastFrameTime = currentTime;
                const frameTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;
                const lag = Math.min(frameTime / 16.6667, 5);
                update(frameTime, lag);
                requestAnimationFrame(tick);
            }

            requestAnimationFrame(tick);
            
            mainStage.canvas.addEventListener('click', (e) => {
                const rect = greetingCard.getBoundingClientRect();
                if (e.clientX < rect.left || e.clientX > rect.right || 
                    e.clientY < rect.top || e.clientY > rect.bottom) {
                    const size = getRandomShellSize();
                    const shell = new Shell(randomShell(size.size));
                    shell.launch(e.clientX / stageW, 1 - e.clientY / stageH);
                }
            });
        }
    </script>
</body>
</html>
